%!TEX root = ts.tex

\rSec0[basic]{Basic concepts}

\pnum
In C++ [basic], add the following last paragraph:

\begin{std.txt}
\added{
An \emph{alias} is a name introduced by a \tcode{typedef} declaration, an
\emph{alias-declaration}, or a \emph{using-declaration}. }
\end{std.txt}


\rSec1[basic.fundamental]{Fundamental types}

\pnum
In C++ [basic.fundamental], apply the following change:

\begin{std.txt}
An expression of type \emph{cv} \tcode{void} shall be used only as an expression
statement (\cxxref{stmt.expr}), as an operand of a comma expression
(\cxxref{expr.comma}), as a second or
third operand of \tcode{?:} (\cxxsec{expr.cond}), as the operand of \tcode{typeid},
\tcode{noexcept}, \added{\tcode{reflexpr},} or \tcode{decltype}, as the
expression in a return statement (\cxxsec{stmt.return}) for a function with the return type
\emph{cv} \tcode{void}, or as the operand of an explicit conversion to type
\emph{cv} \tcode{void}.
\end{std.txt}

\rSec1[basic.def.odr]{One-definition rule}

\pnum
In C++ [basic.def.odr], insert a new paragraph after the existing paragraph 8:

\begin{std.txt}
\added{
A function or static variable reflected by \tcode{T} [dcl.type.reflexpr] is
odr-used by the specialization
\tcode{std::experimental::reflect::get_pointer<T>} (\ref{reflect.ops.derived},
\ref{reflect.ops.memfct}), as
if by taking the address of an \grammarterm{id-expression} nominating the
function or variable.
}
\end{std.txt}

\pnum
In C++ [basic.def.odr], insert a new bullet
(\cxxref{basic.def.odr.odrparagraph2}) after
(\cxxref{basic.def.odr.odrparagraph1}):
\begin{std.txt}
\added{or}
\begin{itemize}
\item \added{a type implementing \tcode{std::experimental::reflect::Object}
(\ref{reflect.concepts.object}), as long as all operations (\ref{reflect.ops})
on this type yield the same constant expression results.}
\end{itemize}
\end{std.txt}

\rSec0[conv]{Standard conversions}

No changes are made to Clause \the\value{chapter} of the \Cpp Standard.
