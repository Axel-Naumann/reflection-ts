\rSec0[expr]{Expressions}

\setcounter{section}{3}
\rSec1[expr.prim]{Primary expressions}
\setcounter{subsection}{4}
\rSec2[expr.prim.lambda]{Lambda expressions}
\setcounter{subsubsection}{1}
\rSec3[expr.prim.lambda.capture]{Captures}

\pnum
In C++ [expr.prim.lambda.capture], apply the following change to paragraph 7:
\begin{std.txt}
If an expression potentially references a local entity within a declarative
region in which it is odr-usable, and the expression would be potentially
evaluated if the effect of any enclosing \tcode{typeid} expressions
(\cxxref{expr.typeid}) \added{or use of a \grammarterm{reflexpr-specifier}
(\ref{dcl.type.reflexpr})} were ignored, the entity is said to be
\emph{implicitly captured} by each intervening \grammarterm{lambda-expression}
with an associated \grammarterm{capture-default} that does not explicitly
capture it.
\end{std.txt}

\pnum
In C++ [expr.prim.lambda.capture], apply the following change to paragraph 11:
\begin{std.txt}
Every \grammarterm{id-expression} within the \grammarterm{compound-statement} of
a \grammarterm{lambda-expression} that is an odr-use (\cxxref{basic.def.odr}) of
an entity captured by copy\added{, as well as every use of an entity captured by
copy in a \grammarterm{reflexpr-operand}, }is transformed into an access to the
corresponding unnamed data member of the closure type.
\end{std.txt}

\rSec1[expr.compound]{Compound expressions}
\rSec2[expr.post]{Postfix expressions}

\pnum
In C++ [expr.post], apply the following change:

\begin{std.txt}
\begin{bnf}
\nontermdef{postfix-expression}\br
    primary-expression\br
    postfix-expression \terminal{[} expr-or-braced-init-list \terminal{]}\br
    \removed{postfix-expression \terminal{(} \opt{expression-list} \terminal{)}}\br
    \added{function-call-expression}\br
    \removed{simple-type-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \removed{typename-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \removed{simple-type-specifier braced-init-list}\br
    \removed{typename-specifier braced-init-list}\br
    \added{functional-type-conv-expression}\br
    postfix-expression \opt{\terminal{. template}} id-expression\br
    postfix-expression \opt{\terminal{-> template}} id-expression\br
    postfix-expression \terminal{.} pseudo-destructor-name\br
    postfix-expression \terminal{->} pseudo-destructor-name\br
    postfix-expression \terminal{++}\br
    postfix-expression \terminal{-{-}}\br
    \terminal{dynamic_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{static_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{reinterpret_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{const_cast <} type-id \terminal{> (} expression \terminal{)}\br
    \terminal{typeid (} expression \terminal{)}\br
    \terminal{typeid (} type-id \terminal{)}
\end{bnf}
\begin{bnf}
\added{\nontermdef{function-call-expression}}\br
    \added{postfix-expression \terminal{(} \opt{expression-list} \terminal{)}}\br
\end{bnf}
\begin{bnf}
\added{\nontermdef{functional-type-conv-expression}}\br
    \added{simple-type-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \added{typename-specifier \terminal{(} \opt{expression-list} \terminal{)}}\br
    \added{simple-type-specifier braced-init-list}\br
    \added{typename-specifier braced-init-list}\br
\end{bnf}
\begin{bnf}
\nontermdef{expression-list}\br
    initializer-list\br
\end{bnf}
\end{std.txt}

\rSec0[stmt.stmt]{Statements}

No changes are made to Clause \the\value{chapter} of the \Cpp Standard.
