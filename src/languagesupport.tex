%!TEX root = ts.tex

\rSec0[language.support]{Language support library}

\pnum
Add a new subclause \ref{reflect} titled "\textbf{Static reflection}" as follows:

\setcounter{section}{11}

\rSec1[reflect]{Static reflection}
\rSec2[reflect.general]{In general}

\begin{std.txt}\color{addclr}

\pnum
As laid out in \ref{dcl.type.reflexpr}, compile-time constant metadata,
describing various aspects of a program (static reflection data), can be
accessed through meta-object types.  The actual metadata is obtained by
instantiating templates constituting the interface of the meta-object types.
These templates are collectively referred to as \emph{meta-object operations}.

\pnum
Meta-object types satisfy different concepts (\ref{reflect.concepts}) depending on the type
they reflect (\ref{dcl.type.reflexpr}).  These concepts can also be used for
meta-object type classification.  They form a generalization-specialization
hierarchy, with \tcode{reflect::Object} being the common generalization for all
meta-object types.  Unary operations and type transformations used to query
static reflection data associated with these concepts are described in
\ref{reflect.ops}.
  
\end{std.txt}

% 21.11.2
\rSec2[reflect.synopsis]{Header \tcode{<experimental/reflect>} synopsis}

\begin{std.txt}\color{addclr}
\begin{codeblock}
namespace std::experimental::reflect {
inline namespace v1 {

// \ref{reflect.concepts} Concepts for meta-object types
template <class T> concept Object;
template <class T> concept ObjectSequence;            // refines Object
template <class T> concept Named;                     // refines Object
template <class T> concept Alias;                     // refines Named and ScopeMember
template <class T> concept RecordMember;              // refines ScopeMember
template <class T> concept Enumerator;                // refines Constant
template <class T> concept Variable;                  // refines Typed and ScopeMember
template <class T> concept ScopeMember;               // refines Named
template <class T> concept Typed;                     // refines Object
template <class T> concept Namespace;                 // refines Named and Scope
template <class T> concept GlobalScope;               // refines Namespace
template <class T> concept Class;                     // refines Record
template <class T> concept Enum;                      // refines Type and Scope
template <class T> concept Record;                    // refines Type and Scope
template <class T> concept Scope;                     // refines Object
template <class T> concept Type;                      // refines Named and ScopeMember
template <class T> concept Constant;                  // refines Typed and ScopeMember
template <class T> concept Base;                      // refines Object
template <class T> concept FunctionParameter;         // refines Typed and ScopeMember
template <class T> concept Callable;                  // refines Scope and ScopeMember
template <class T> concept Expression;                // refines Object
template <class T> concept ParenthesizedExpression;   // refines Expression
template <class T> concept FunctionCallExpression;    // refines Expression
template <class T> concept FunctionalTypeConversion;  // refines Expression
template <class T> concept Function;                  // refines Typed and Callable
template <class T> concept MemberFunction;            // refines RecordMember and Function
template <class T> concept SpecialMemberFunction;     // refines RecordMember
template <class T> concept Constructor;               // refines Callable and RecordMember
template <class T> concept Destructor;                // refines Callable and
                                                      // SpecialMemberFunction
template <class T> concept Operator;                  // refines Function
template <class T> concept ConversionOperator;        // refines MemberFunction and
                                                      // Operator
template <class T> concept Lambda;                    // refines Type and Scope
template <class T> concept LambdaCapture;             // refines Variable


// \ref{reflect.ops} Meta-object operations
// Multi-concept operations
template <Object T> struct is_public;
template <Object T> struct is_protected;
template <Object T> struct is_private;
template <Object T> struct is_constexpr;
template <Object T> struct is_static;
template <Object T> struct is_final;
template <Object T> struct is_explicit;
template <Object T> struct is_inline;
template <Object T> struct is_virtual;
template <Object T> struct is_pure_virtual;
template <Object T> struct get_pointer;

template <class T>
  constexpr auto is_public_v = is_public<T>::value;
template <class T>
  constexpr auto is_protected_v = is_protected<T>::value;
template <class T>
  constexpr auto is_private_v = is_private<T>::value;
template <class T>
   constexpr auto is_constexpr_v = is_constexpr<T>::value;
template <class T>
   constexpr auto is_static_v = is_static<T>::value;
template <class T>
   constexpr auto is_final_v = is_final<T>::value;
template <class T>
   constexpr auto is_explicit_v = is_explicit<T>::value;
template <class T>
   constexpr auto is_inline_v = is_inline<T>::value;
template <class T>
   constexpr auto is_virtual_v = is_virtual<T>::value;
template <class T>
   constexpr auto is_pure_virtual_v = is_pure_virtual<T>::value;
template <class T>
   constexpr auto get_pointer_v = get_pointer<T>::value;

// \ref{reflect.ops.object} Object operations
template <Object T1, Object T2> struct reflects_same;
template <Object T> struct get_source_line;
template <Object T> struct get_source_column;
template <Object T> struct get_source_file_name;

template <Object T1, Object T2>
  constexpr auto reflects_same_v = reflects_same<T1, T2>::value;
template <class T>
  constexpr auto get_source_line_v = get_source_line<T>::value;
template <class T>
  constexpr auto get_source_column_v = get_source_column<T>::value;
template <class T>
  constexpr auto get_source_file_name_v = get_source_file_name<T>::value;

// \ref{reflect.ops.objseq} ObjectSequence operations
template <ObjectSequence T> struct get_size;
template <size_t I, ObjectSequence T> struct get_element;
template <template <class...> class Tpl, ObjectSequence T>
  struct unpack_sequence;

template <ObjectSequence T>
  constexpr auto get_size_v = get_size<T>::value;
template <size_t I, ObjectSequence T>
  using get_element_t = typename get_element<I, T>::type;
template <template <class...> class Tpl, ObjectSequence T>
  using unpack_sequence_t = unpack_sequence<Tpl, T>::type;

// \ref{reflect.ops.named} Named operations
template <Named T> struct is_unnamed;
template <Named T> struct get_name;
template <Named T> struct get_display_name;

template <Named T>
  constexpr auto is_unnamed_v = is_unnamed<T>::value;
template <Named T>
  constexpr auto get_name_v = get_name<T>::value;
template <Named T>
  constexpr auto get_display_name_v = get_display_name<T>::value;

// \ref{reflect.ops.alias} Alias operations
template <Alias T> struct get_aliased;

template <Alias T>
  using get_aliased_t = typename get_aliased<T>::type;

// \ref{reflect.ops.type} Type operations
template <Typed T> struct get_type;
template <Type T> struct get_reflected_type;
template <Type T> struct is_enum;
template <Type T> struct is_class;
template <Type T> struct is_struct;
template <Type T> struct is_union;

template <Typed T>
  using get_type_t = typename get_type<T>::type;
template <Type T>
  using get_reflected_type_t = typename get_reflected_type<T>::type;
template <Type T>
  constexpr auto is_enum_v = is_enum<T>::value;
template <Type T>
  constexpr auto is_class_v = is_class<T>::value;
template <Type T>
  constexpr auto is_struct_v = is_struct<T>::value;
template <Type T>
  constexpr auto is_union_v = is_union<T>::value;

// \ref{reflect.ops.member} Member operations
template <ScopeMember T> struct get_scope;
template <RecordMember T> struct is_public<T>;
template <RecordMember T> struct is_protected<T>;
template <RecordMember T> struct is_private<T>;

template <ScopeMember T>
  using get_scope_t = typename get_scope<T>::type;

// \ref{reflect.ops.record} Record operations
template <Record T> struct get_public_data_members;
template <Record T> struct get_accessible_data_members;
template <Record T> struct get_data_members;
template <Record T> struct get_public_member_functions;
template <Record T> struct get_accessible_member_functions;
template <Record T> struct get_member_functions;
template <Record T> struct get_public_member_types;
template <Record T> struct get_accessible_member_types;
template <Record T> struct get_member_types;
template <Record T> struct get_constructors;
template <Record T> struct get_destructor;
template <Record T> struct get_operators;
template <Class T> struct get_public_base_classes;
template <Class T> struct get_accessible_base_classes;
template <Class T> struct get_base_classes;
template <Class T> struct is_final<T>;

template <Record T>
  using get_public_data_members_t = typename get_public_data_members<T>::type;
template <Record T>
  using get_accessible_data_members_t = typename get_accessible_data_members<T>::type;
template <Record T>
  using get_data_members_t = typename get_data_members<T>::type;
template <Record T>
  using get_public_member_functions_t = typename get_public_member_functions<T>::type;
template <Record T>
  using get_accessible_member_functions_t = typename get_accessible_member_functions<T>::type;
template <Record T>
  using get_member_functions_t = typename get_member_functions<T>::type;
template <Record T>
  using get_public_member_types_t = typename get_public_member_types<T>::type;
template <Record T>
  using get_accessible_member_types_t = typename get_accessible_member_types<T>::type;
template <Record T>
  using get_member_types_t = typename get_member_types<T>::type;
template <Record T>
  using get_constructors_t = typename get_constructors<T>::type;
template <Record T>
  using get_destructor_t = typename get_destructor<T>::type;
template <Record T>
  using get_operators_t = typename get_operators<T>::type;
template <Class T>
  using get_public_base_classes_t = typename get_public_base_classes<T>::type;
template <Class T>
  using get_accessible_base_classes_t = typename get_accessible_base_classes<T>::type;
template <Class T>
  using get_base_classes_t = typename get_base_classes<T>::type;

// \ref{reflect.ops.enum} Enum operations
template <Enum T> struct is_scoped_enum;
template <Enum T> struct get_enumerators;
template <Enum T> struct get_underlying_type;

template <Enum T>
  constexpr auto is_scoped_enum_v = is_scoped_enum<T>::value;
template <Enum T>
  using get_enumerators_t = typename get_enumerators<T>::type;
template <Enum T>
  using get_underlying_type_t = typename get_underlying_type<T>::type;

// \ref{reflect.ops.value} Value operations
template <Constant T> struct get_constant;
template <Variable T> struct is_constexpr<T>;
template <Variable T> struct is_static<T>;
template <Variable T> struct get_pointer<T>;

template <Constant T>
  constexpr auto get_constant_v = get_constant<T>::value;

// \ref{reflect.ops.derived} Base operations
template <Base T> struct get_class;
template <Base T> struct is_virtual<T>;
template <Base T> struct is_public<T>;
template <Base T> struct is_protected<T>;
template <Base T> struct is_private<T>;

template <Base T>
  using get_class_t = typename get_class<T>::type;

// \ref{reflect.ops.namespace} Namespace operations
template <Namespace T> struct is_inline<T>;

// \ref{reflect.ops.fctparam} FunctionParameter operations
template <FunctionParameter T> struct has_default_argument;

template <FunctionParameter T>
  constexpr auto has_default_argument_v = has_default_argument<T>::value;

// \ref{reflect.ops.callable} Callable operations
template <Callable T> struct get_parameters;
template <Callable T> struct is_vararg;
template <Callable T> struct is_constexpr<T>;
template <Callable T> struct is_noexcept<T>;
template <Callable T> struct is_inline<T>;
template <Callable T> struct is_deleted;

template <Callable T>
  using get_parameters_t = typename get_parameters<T>::type;
template <Callable T>
  constexpr auto is_vararg_v = is_vararg<T>::value;
template <Callable T>
  constexpr auto is_deleted_v = is_deleted<T>::value;

// \ref{reflect.ops.expr.paren} ParenthesizedExpression operations
template <ParenthesizedExpression T> struct get_subexpression;

template <ParenthesizedExpression T>
   using get_subexpression_t = typename get_subexpression<T>::type;

// \ref{reflect.ops.expr.fctcall} FunctionCallExpression operations
template <FunctionCallExpression T> struct get_callable;

template <FunctionCallExpression T>
  using get_callable_t = typename get_callable<T>::type;

// \ref{reflect.ops.expr.fcttypeconv} FunctionalTypeConversion operations
template <FunctionalTypeConversion T> struct get_constructor;

template <FunctionalTypeConversion T>
  using get_constructor_t = typename get_constructor<T>::type;

// \ref{reflect.ops.fct} Function operations
template <Function T> struct get_pointer<T>;

// \ref{reflect.ops.memfct} MemberFunction operations
template <MemberFunction T> struct is_static<T>;
template <MemberFunction T> struct is_const;
template <MemberFunction T> struct is_volatile;
template <MemberFunction T> struct has_lvalueref_qualifier;
template <MemberFunction T> struct has_rvalueref_qualifier;
template <MemberFunction T> struct is_virtual<T>;
template <MemberFunction T> struct is_pure_virtual<T>;
template <MemberFunction T> struct is_override;
template <MemberFunction T> struct is_final<T>;

template <MemberFunction T>
  constexpr auto is_const_v = is_const<T>::value;
template <MemberFunction T>
  constexpr auto is_volatile_v = is_volatile<T>::value;
template <MemberFunction T>
  constexpr auto has_lvalueref_qualifier_v = has_lvalueref_qualifier<T>::value;
template <MemberFunction T>
  constexpr auto has_rvalueref_qualifier_v = has_rvalueref_qualifier<T>::value;
template <MemberFunction T>
  constexpr auto is_override_v = is_override<T>::value;

// \ref{reflect.ops.specialfct} SpecialMemberFunction operations
template <SpecialMemberFunction T> struct is_implicitly_declared;
template <SpecialMemberFunction T> struct is_defaulted;

template <SpecialMemberFunction T>
  constexpr auto is_implicitly_declared_v = is_implicitly_declared<T>::value;
template <SpecialMemberFunction T>
  constexpr auto is_defaulted_v = is_defaulted<T>::value;

// \ref{reflect.ops.ctor} Constructor operations
template <Constructor T> struct is_explicit<T>;

// \ref{reflect.ops.dtor} Destructor operations
template <Destructor T> struct is_virtual<T>;
template <Destructor T> struct is_pure_virtual<T>;

// \ref{reflect.ops.convfct} ConversionOperator operations
template <ConversionOperator T> struct is_explicit<T>;

// \ref{reflect.ops.lambda} Lambda operations
template <Lambda T> struct get_captures;
template <Lambda T> struct uses_default_copy_capture;
template <Lambda T> struct uses_default_reference_capture;
template <Lambda T> struct is_call_operator_const;

template <Lambda T>
  using get_captures_t = typename get_captures<T>::type;
template <Lambda T>
  constexpr auto uses_default_copy_capture_v = uses_default_copy_capture<T>::value;
template <Lambda T>
  constexpr auto uses_default_reference_capture_v = uses_default_reference_capture<T>::value;
template <Lambda T>
  constexpr auto is_call_operator_const_v = is_call_operator_const<T>::value;

// \ref{reflect.ops.lambdacapture} LambdaCapture operations
template <LambdaCapture T> struct is_explicitly_captured;
template <LambdaCapture T> struct is_init_capture;

template <LambdaCapture T>
  constexpr auto is_explicitly_captured_v = is_explicitly_captured<T>::value;
template <LambdaCapture T>
  constexpr auto is_init_capture_v = is_init_capture<T>::value;

} // inline namespace v1
} // namespace std::experimental::reflect
\end{codeblock}
\end{std.txt}

% 21.11.3
\rSec2[reflect.concepts]{Concepts for meta-object types}

\begin{std.txt}\color{addclr}
\pnum
The operations on meta-object types defined here require meta-object types to
satisfy certain concepts (\cxxref{temp.concept}). These concepts are also used to
specify the result type for \emph{TransformationTrait} type transformations that
yield meta-object types.
\end{std.txt}

% 21.11.3.1
\rSec3[reflect.concepts.object]{Concept \tcode{Object}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Object = @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Object<T>} is true if and only if \tcode{T} is a meta-object type, as generated by the \tcode{reflexpr} operator or any of the meta-object operations that in turn generate meta-object types.

\end{itemdescr}
\end{std.txt}

% 21.11.3.2
\rSec3[reflect.concepts.objseq]{Concept \tcode{ObjectSequence}}
\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept ObjectSequence = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{ObjectSequence<T>} is true if and only if \tcode{T} is a sequence of \tcode{Object}s, generated by a meta-object operation.

\end{itemdescr}
\end{std.txt}

% 21.11.3.3
\rSec3[reflect.concepts.named]{Concept \tcode{Named}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Named = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Named<T>} is true if and only if \tcode{T} has an associated (possibly empty) name.

\end{itemdescr}
\end{std.txt}

% 21.11.3.4
\rSec3[reflect.concepts.alias]{Concept \tcode{Alias}}


\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Alias = Named<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Alias<T>} is true if and only if \tcode{T} reflects a \tcode{typedef} declaration, an \grammarterm{alias-declaration}, a \grammarterm{namespace-alias}, a template \grammarterm{type-parameter}, a \grammarterm{decltype-specifier}, or a declaration introduced by a \grammarterm{using-declaration}.
\begin{note}
The \tcode{Scope} of an \tcode{Alias} is the scope that the alias was injected into.
\end{note}
\begin{example}
\begin{codeblock}
namespace N {
   struct A;
}
namespace M {
   using X = N::A;
}
using M_X_t = reflexpr(M::X);
using M_X_scope_t = get_scope_t<M_X_t>;
\end{codeblock}
The scope reflected by \tcode{M_X_scope_t} is \tcode{M}, not \tcode{N}.
\end{example}

\pnum
Except for the type represented by the \tcode{reflexpr} operator, \tcode{Alias}
properties resulting from type transformations (\ref{reflect.ops}) are not retained.

\end{itemdescr}
\end{std.txt}

% 21.11.3.5
\rSec3[reflect.concepts.recordmember]{Concept \tcode{RecordMember}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept RecordMember = ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{RecordMember<T>} is true if and only if \tcode{T} reflects a \grammarterm{member-declaration}.

\end{itemdescr}
\end{std.txt}

% 21.11.3.6
\rSec3[reflect.concepts.enumerator]{Concept \tcode{Enumerator}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Enumerator = Typed<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Enumerator<T>} is true if and only if \tcode{T} reflects an enumerator. \begin{note} The \tcode{Scope} of an \tcode{Enumerator} is its type also for enumerations that are unscoped enumeration types. \end{note}

\end{itemdescr}
\end{std.txt}

% 21.11.3.7
\rSec3[reflect.concepts.variable]{Concept \tcode{Variable}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Variable = Typed<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Variable<T>} is true if and only if \tcode{T} reflects a variable or data member.

\end{itemdescr}
\end{std.txt}

% 21.11.3.8
\rSec3[reflect.concepts.scopemember]{Concept \tcode{ScopeMember}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept ScopeMember = Named<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{ScopeMember<T>} is true if and only if \tcode{T} satisfies \tcode{RecordMember}, \tcode{Enumerator}, or \tcode{Variable}, or if \tcode{T} reflects a namespace that is not the global namespace. \begin{note} The scope of members of an unnamed union is the unnamed union; the scope of enumerators is their type. \end{note}

\end{itemdescr}
\end{std.txt}

% 21.11.3.9
\rSec3[reflect.concepts.typed]{Concept \tcode{Typed}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Typed = Named<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Typed<T>} is true if and only if \tcode{T} reflects an entity with a type.

\end{itemdescr}
\end{std.txt}

% 21.11.3.10
\rSec3[reflect.concepts.namespace]{Concept \tcode{Namespace}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Namespace = Scope<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Namespace<T>} is true if and only if \tcode{T} reflects a namespace (including the global namespace). \begin{note} Any such \tcode{T} that does not reflect the global namespace also satisfies \tcode{ScopeMember}. \end{note}

\end{itemdescr}
\end{std.txt}

% 21.11.3.11
\rSec3[reflect.concepts.globalscope]{Concept \tcode{GlobalScope}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept GlobalScope = Namespace<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{GlobalScope<T>} is true if and only if \tcode{T} reflects the global namespace. \begin{note} Any such \tcode{T} does not satisfy \tcode{ScopeMember}. \end{note}

\end{itemdescr}
\end{std.txt}

% 21.11.3.12
\rSec3[reflect.concepts.class]{Concept \tcode{Class}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Class = Record<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Class<T>} is true if and only if \tcode{T} reflects a non-union class type.

\end{itemdescr}
\end{std.txt}

% 21.11.3.13
\rSec3[reflect.concepts.enum]{Concept \tcode{Enum}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Enum = Type<T> && Scope<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Enum<T>} is true if and only if \tcode{T} reflects an enumeration type.

\end{itemdescr}
\end{std.txt}

% 21.11.3.14
\rSec3[reflect.concepts.record]{Concept \tcode{Record}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Record = Type<T> && Scope<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Record<T>} is true if and only if \tcode{T} reflects a class type.

\end{itemdescr}
\end{std.txt}

% 21.11.3.15
\rSec3[reflect.concepts.scope]{Concept \tcode{Scope}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Scope = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Scope<T>} is true if and only if \tcode{T} reflects a namespace (including the global namespace), class, enumeration, function or closure type. \begin{note} Any such \tcode{T} that does not reflect the global namespace also satisfies \tcode{ScopeMember}. \end{note}

\end{itemdescr}
\end{std.txt}

% 21.11.3.16
\rSec3[reflect.concepts.type]{Concept \tcode{Type}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Type = Named<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Type<T>} is true if and only if \tcode{T} reflects a type.

\end{itemdescr}
\end{std.txt}

% 21.11.3.17
\rSec3[reflect.concepts.const]{Concept \tcode{Constant}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Constant = ScopeMember<T> && Typed<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Constant<T>} is true if and only if \tcode{T} reflects a constant
expression (\cxxref{expr.const}).

\end{itemdescr}
\end{std.txt}

% 21.11.3.18
\rSec3[reflect.concepts.base]{Concept \tcode{Base}}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <class T> concept Base = Object<T> && @\seebelow@;
\end{itemdecl}

\begin{itemdescr}
\pnum
\tcode{Base<T>} is true if and only if \tcode{T} reflects a direct base class, as returned by the template \tcode{get_base_classes}.

\end{itemdescr}
\end{std.txt}

% 21.11.3.19
\rSec3[reflect.concepts.fctparam]{Concept \tcode{FunctionParameter}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept FunctionParameter = Typed<T> && ScopeMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{FunctionParameter<T>} is \tcode{true} if and only if \tcode{T} reflects a function parameter.
\begin{note} The \tcode{Scope} of a \tcode{FunctionParameter} is the \tcode{Callable} to which this parameter appertains. \end{note}
\begin{note} A \tcode{FunctionParameter} does not satisfy \tcode{Variable}, and thus does not offer an interface for getting the pointer to a parameter. \end{note}
\end{itemdescr}
\end{std.txt}

% 21.11.3.20
\rSec3[reflect.concepts.callable]{Concept \tcode{Callable}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Callable = ScopeMember<T> && Scope<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Callable<T>} is \tcode{true} if and only if \tcode{T} reflects a function, including constructors and destructors.
\end{itemdescr}
\end{std.txt}

% 21.11.3.21
\rSec3[reflect.concepts.expr]{Concept \tcode{Expression}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Expression = Object<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Expression<T>} is \tcode{true} if and only if \tcode{T} reflects an
expression (Clause \cxxref{expr}).
\end{itemdescr}
\end{std.txt}

% 21.11.3.22
\rSec3[reflect.concepts.expr.paren]{Concept \tcode{ParenthesizedExpression}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept ParenthesizedExpression = Expression<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{ParenthesizedExpression<T>} is \tcode{true} if and only if \tcode{T}
reflects a parenthesized expression (\cxxref{expr.prim.paren}).
\end{itemdescr}
\end{std.txt}

% 21.11.3.23
\rSec3[reflect.concepts.expr.fctcall]{Concept \tcode{FunctionCallExpression}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept FunctionCallExpression = Expression<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{FunctionCallExpression<T>} is \tcode{true} if and only if \tcode{T}
reflects a \grammarterm{function-call-expression} (\cxxref{expr.call}).
\end{itemdescr}
\end{std.txt}

% 21.11.3.24
\rSec3[reflect.concepts.expr.type.fctconv]{Concept \tcode{FunctionalTypeConversion}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept FunctionalTypeConversion = Expression<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{FunctionalTypeConversion<T>} is \tcode{true} if and only if \tcode{T}
reflects a \grammarterm{functional-type-conv-expression} (\cxxref{expr.type.conv}).
\end{itemdescr}
\end{std.txt}

% 21.11.3.25
\rSec3[reflect.concepts.fct]{Concept \tcode{Function}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Function = Callable<T> && Typed<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Function<T>} is \tcode{true} if and only if \tcode{T} reflects a function, excluding constructors and destructors.
\end{itemdescr}
\end{std.txt}

% 21.11.3.26
\rSec3[reflect.concepts.memfct]{Concept \tcode{MemberFunction}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept MemberFunction = RecordMember<T> && Function<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{MemberFunction<T>} is \tcode{true} if and only if \tcode{T} reflects a member function, excluding constructors and destructors.
\end{itemdescr}
\end{std.txt}

% 21.11.3.27
\rSec3[reflect.concepts.specialfct]{Concept \tcode{SpecialMemberFunction}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept SpecialMemberFunction = RecordMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{SpecialMemberFunction<T>} is \tcode{true} if and only if \tcode{T}
reflects a special member function (Clause \cxxref{special}).
\end{itemdescr}
\end{std.txt}

% 21.11.3.28
\rSec3[reflect.concepts.ctor]{Concept \tcode{Constructor}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Constructor = Callable<T> && RecordMember<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Constructor<T>} is \tcode{true} if and only if \tcode{T} reflects a constructor. \begin{note} Some types that satisfy \tcode{Constructor} also satisfy \tcode{SpecialMemberFunction}. \end{note}
\end{itemdescr}
\end{std.txt}

% 21.11.3.29
\rSec3[reflect.concepts.dtor]{Concept \tcode{Destructor}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Destructor = Callable<T> && SpecialMemberFunction<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Destructor<T>} is \tcode{true} if and only if \tcode{T} reflects a destructor.
\end{itemdescr}
\end{std.txt}

% 21.11.3.30
\rSec3[reflect.concepts.oper]{Concept \tcode{Operator}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Operator = Function<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Operator<T>} is \tcode{true} if and only if \tcode{T} reflects an operator function (\cxxref{over.oper}) or a conversion function (\cxxref{class.conv.fct}). \begin{note} Some types that satisfy \tcode{Operator} also satisfy \tcode{MemberFunction} or \tcode{SpecialMemberFunction}. \end{note}
\end{itemdescr}
\end{std.txt}

% 21.11.3.31
\rSec3[reflect.concepts.convfct]{Concept \tcode{ConversionOperator}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept ConversionOperator = Operator<T> && MemberFunction<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{ConversionOperator<T>} is \tcode{true} if and only if \tcode{T} reflects a conversion function (\cxxref{class.conv.fct}).
\end{itemdescr}
\end{std.txt}

% 21.11.3.32
\rSec3[reflect.concepts.lambda]{Concept \tcode{Lambda}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept Lambda = Type<T> && Scope<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{Lambda<T>} is \tcode{true} if and only if \tcode{T} reflects a closure object (excluding generic lambdas).
\end{itemdescr}
\end{std.txt}

% 21.11.3.33
\rSec3[reflect.concepts.lambdacapture]{Concept \tcode{LambdaCapture}}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <class T> concept LambdaCapture = Variable<T> && @\seebelow@;
\end{itemdecl}
\begin{itemdescr}
\pnum
\tcode{LambdaCapture<T>} is \tcode{true} if and only if \tcode{T} reflects a lambda capture as introduced by the capture list or by capture defaults. \begin{note} The \tcode{Scope} of a \tcode{LambdaCapture} is its immediately enclosing \tcode{Lambda}. \end{note}
\end{itemdescr}
\end{std.txt}

% 21.11.4
\rSec2[reflect.ops]{Meta-object operations}

\begin{std.txt}\color{addclr}
\pnum
A meta-object operation extracts information from meta-object types. It is a class template taking one or more arguments, at least one of which models the \tcode{Object} concept. The result of a meta-object operation can be either a constant expression (\cxxref{expr.const}) or a type.

\pnum
Some operations specify result types with a nested type called \tcode{type} that satisfies one of the concepts in \tcode{reflect}.
These nested types will possibly satisfy other concepts, for instance more specific ones, or independent ones, as applicable for the entity reflected by the nested type.
\begin{example}\begin{codeblock}
struct X {};
X x;
using x_t = get_type_t<reflexpr(x)>;\end{codeblock}
While \tcode{get_type_t} is specified to be a \tcode{Type}, \tcode{x_t} also satisfies \tcode{Class}. \end{example}

\pnum
If subsequent specializations of operations on the same reflected entity could give different constant expression results (for instance for \tcode{get_name_v} because the parameter's function is redeclared with a different parameter name between the two points of instantiation), the program is ill-formed, no diagnostic required.
   \begin{example}\begin{codeblock}
void func(int a);
auto x1 = get_name_v<get_element_t<0, get_parameters_t<reflexpr(func(42))>>>;
void func(int b);
auto x2 = get_name_v<get_element_t<0, get_parameters_t<reflexpr(func(42))>>>; // ill-formed,
                                                                    // no diagnostic required\end{codeblock}
\end{example}

\end{std.txt}

% 21.11.4.1
\rSec3[reflect.ops.object]{Object operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Object T1, Object T2> struct reflects_same;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{reflects_same<T1, T2>} shall meet the \tcode{BinaryTypeTrait} requirements (\cxxref{meta.rqmts}),
    with a base characteristic of \tcode{true_type} if 
\begin{itemize}
  \item \tcode{T1} and \tcode{T2} reflect the same alias, or
  \item neither \tcode{T1} nor \tcode{T2} reflect an alias and \tcode{T1} and \tcode{T2} reflect the same entity;
\end{itemize}
    otherwise, with a base characteristic of \tcode{false_type}.

\pnum
\begin{example}
With
\begin{codeblock}
class A;
using a0 = reflexpr(A);
using a1 = reflexpr(A);
class A {};
using a2 = reflexpr(A);
constexpr bool b1 = is_same_v<a0, a1>; // unspecified value
constexpr bool b2 = reflects_same_v<a0, a1>; // true
constexpr bool b3 = reflects_same_v<a0, a2>; // true

struct C { };
using C1 = C;
using C2 = C;
constexpr bool b4 = reflects_same_v<reflexpr(C1), reflexpr(C2)>; // false
\end{codeblock}
\end{example}

\end{itemdescr}


\begin{itemdecl}
template <Object T> struct get_source_line;
template <Object T> struct get_source_column;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of above templates shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a base characteristic of \tcode{integral_constant<uint_least32_t>} and a value of the presumed line number (\cxxref{cpp.predefined}) (for \tcode{get_source_line<T>}) and an implementation-defined value representing some offset from the start of the line (for \tcode{get_source_column<T>}) of the most recent declaration of the entity or typedef described by \tcode{T}.
\end{itemdescr}

\begin{itemdecl}
template <Object T> struct get_source_file_name;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_source_file_name<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a static data member named \tcode{value} of type \tcode{const char (\&)[N]}, referencing a static, constant expression character array (NTBS) of length \tcode{N}, as if declared as \tcode{static constexpr char STR[N] = ...;}. The value of the NTBS is the presumed name of the source file (\cxxref{cpp.predefined}) of the most recent declaration of the entity or typedef described by \tcode{T}.

\end{itemdescr}

\end{std.txt}

% 21.11.4.2
\rSec3[reflect.ops.objseq]{ObjectSequence operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <ObjectSequence T> struct get_size;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_size<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a base characteristic of \tcode{integral_constant<size_t, N>}, where \tcode{N} is the number of elements in the object sequence.
\end{itemdescr}

\begin{itemdecl}
template <size_t I, ObjectSequence T> struct get_element;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_element<I, T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} corresponds to the \tcode{I}th element \tcode{Object} in \tcode{T}, where the indexing is zero-based.
\end{itemdescr}

\begin{itemdecl}
template <template <class...> class Tpl, ObjectSequence T> struct unpack_sequence;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{unpack_sequence<Tpl, T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to the template \tcode{Tpl} specialized with the element \tcode{Object}s in \tcode{T}.
\end{itemdescr}
\end{std.txt}

% 21.11.4.3
\rSec3[reflect.ops.named]{Named operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Named T> struct is_unnamed;
template <Named T> struct get_name;
template <Named T> struct get_display_name;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_unnamed<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a base characteristic as specified below.

\pnum
All specializations of \tcode{get_name<T>} and \tcode{get_display_name<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}) with a static data member named \tcode{value} of type \tcode{const char (\&)[N]}, referencing a static, constant expression character array (NTBS) of length \tcode{N}, as if declared as \tcode{static constexpr char STR[N] = ...;}.

\begin{itemize}
\item For \tcode{T} reflecting an unnamed entity, the string's value is the empty string.
\item For \tcode{T} reflecting a \grammarterm{decltype-specifier}, the string's value is the empty string for \tcode{get_name<T>} and implementation-defined for \tcode{get_display_name<T>}.
\item For \tcode{T} reflecting an array, pointer, reference of function type, or a \emph{cv}-qualified type, the string's value is the empty string for \tcode{get_name<T>} and implementation-defined for \tcode{get_display_name<T>}.
\item In the following cases, the string's value is implementation-defined for \tcode{get_display_name<T>} and has the following value for \tcode{get_name<T>}:
\begin{itemize}
  \item for \tcode{T} reflecting an \tcode{Alias}, the unqualified name of the aliasing declaration: the identifier introduced by a \grammarterm{type-parameter} or a type name introduced by a \grammarterm{using-declaration}, alias;
  \item for \tcode{T} reflecting a specialization of a class template, its \grammarterm{template-name};
  \item for \tcode{T} reflecting a class type, its \grammarterm{class-name};
  \item for \tcode{T} reflecting a namespace, its \grammarterm{namespace-name};
  \item for \tcode{T} reflecting an enumeration type, its \grammarterm{enum-name};
  \item for \tcode{T} reflecting all other \grammarterm{simple-type-specifiers}, the name stated in the "Type" column of Table 9 in (\cxxref{dcl.type.simple});
  \item for \tcode{T} reflecting a variable, its unqualified name;
  \item for \tcode{T} reflecting an enumerator, its unqualified name;
  \item for \tcode{T} reflecting a class data member, its unqualified name;
  \item for \tcode{T} reflecting a function, its unqualified name;
  \item for \tcode{T} reflecting a specialization of a template function, its \grammarterm{template-name};
  \item for \tcode{T} reflecting a function parameter, its unqualified name;
  \item for \tcode{T} reflecting a constructor, the \grammarterm{injected-class-name} of its class;
  \item for \tcode{T} reflecting a destructor, the \grammarterm{injected-class-name} of its class, prefixed by the character '\tilde';
  \item for \tcode{T} reflecting an operator function, the \grammarterm{operator} element of the relevant \grammarterm{operator-function-id};
  \item for \tcode{T} reflecting a conversion function, the same characters as \tcode{get_name_v<R>}, with \tcode{R} reflecting the type represented by the \grammarterm{conversion-type-id}.
\end{itemize}
\item In all other cases (for instance for \tcode{T} reflecting a lambda object), the string's value is the empty string for \tcode{get_name<T>} and implementation-defined for \tcode{get_display_name<T>}.
\end{itemize}

\pnum
\begin{note}
With
\begin{codeblock}
namespace n { template <class T> class A; }
using a_m = reflexpr(n::A<int>);
\end{codeblock}
the value of \tcode{get_name_v<a_m>} is \tcode{"A"} while the value of \tcode{get_display_name_v<a_m>} might be \tcode{"n::A<int>"}.
\end{note}

\pnum
The base characteristic of \tcode{is_unnamed<T>} is \tcode{true_type} if the value of \tcode{get_name_v<T>} is the empty string, otherwise it is \tcode{false_type}.

\pnum
Subsequent specializations of \tcode{get_name<T>} on the same reflected
function parameter can render the program ill-formed, no diagnostic required
(\ref{reflect.ops}).

\end{itemdescr}

\end{std.txt}


% 21.11.4.4
\rSec3[reflect.ops.alias]{Alias operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Alias T> struct get_aliased;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_aliased<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Named} meta-object type reflecting
\begin{itemize}
\item the redefined name, if \tcode{T} reflects an alias;
\item the template specialization's template argument type, if \tcode{T} reflects a template \grammarterm{type-parameter};
\item the original declaration introduced by a \grammarterm{using-declaration};
\item the aliased namespace of a \grammarterm{namespace-alias};
\item the type denoted by the \grammarterm{decltype-specifier}.
\end{itemize}

\pnum
The nested type named \tcode{type} is not an \tcode{Alias}; instead, it is reflecting the underlying non-\tcode{Alias} entity.

\pnum
\begin{example}
For
\begin{codeblock}
using i0 = int; using i1 = i0;
\end{codeblock}
\tcode{get_aliased_t<reflexpr(i1)>} reflects \tcode{int}.
\end{example}

\end{itemdescr}
\end{std.txt}

% 21.11.4.5
\rSec3[reflect.ops.type]{Type operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Typed T> struct get_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_type<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Type} reflecting the type of the entity reflected by \tcode{T}.

\pnum
\begin{example}
For
\begin{codeblock}
int v; using v_m = reflexpr(v);
\end{codeblock}
\tcode{get_type_t<v_m>} reflects \tcode{int}.
\end{example}

\pnum
If the entity reflected by \tcode{T} is a static data member that is declared to have a type array of unknown bound in the class definition, possible specifications of the array bound will only be accessible when the \grammarterm{reflexpr-operand} is the data member.

\pnum
\begin{note}
For
\begin{codeblock}
struct C {
   static int arr[17][];
};
int C::arr[17][42];
using C1 = get_type_t<get_element_t<0, get_data_members_t<reflexpr(C)>>>;
using C2 = get_type_t<reflexpr(C::arr)>;
\end{codeblock}
\tcode{C1} reflects \tcode{int[17][]} while \tcode{C2} reflects \tcode{int[17][42]}.
\end{note}

\end{itemdescr}
\begin{itemdecl}
template <Type T> struct get_reflected_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_reflected_type<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the type reflected by \tcode{T}.

\pnum
\begin{example}
For
\begin{codeblock}
using int_m = reflexpr(int);
get_reflected_type_t<int_m> x; // x is of type int
\end{codeblock}
\end{example}
\end{itemdescr}

\begin{itemdecl}
template <Type T> struct is_enum;
template <Type T> struct is_union;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_enum<T>} and \tcode{is_union<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects an enumeration type (a union), the base characteristic of \tcode{is_enum<T>} (\tcode{is_union<T>}) is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Type T> struct is_class;
template <Type T> struct is_struct;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_class<T>} and \tcode{is_struct<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a class with \grammarterm{class-key} \tcode{class} (for \tcode{is_class<T>}) or \tcode{struct} (for \tcode{is_struct<T>}), the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}. If the same class has redeclarations with both \grammarterm{class-key} \tcode{class} and \grammarterm{class-key} \tcode{struct}, the base characteristic of the template specialization of exactly one of \tcode{is_class<T>} and \tcode{is_struct<T>} can be \tcode{true_type}, the other template specialization is \tcode{false_type}; the actual choice of value is unspecified.
\end{itemdescr}
\end{std.txt}

% 21.11.4.6
\rSec3[reflect.ops.member]{Member operations}

\begin{std.txt}\color{addclr}
\pnum
A specialization of any of these templates with a meta-object type that is
reflecting an incomplete type renders the program ill-formed.  Such errors are
not in the immediate context (\cxxref{temp.deduct}).


\begin{itemdecl}
template <ScopeMember T> struct get_scope;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_scope<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Scope} reflecting a scope \emph{S}. With \emph{ST} being the scope of the declaration of the entity, typedef or value reflected by \tcode{T}, \emph{S} is found as the innermost scope enclosing \emph{ST} that is either a namespace scope (including global scope), class scope, enumeration scope, function scope (for the function's parameters), or immediately enclosing closure type (for lambda captures). For members of an unnamed union, this innermost scope is the unnamed union. For enumerators of unscoped enumeration types, this innermost scope is their enumeration type.
\end{itemdescr}

\begin{itemdecl}
template <RecordMember T> struct is_public<T>;
template <RecordMember T> struct is_protected<T>;
template <RecordMember T> struct is_private<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these partial template specializations shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a public member (for \tcode{is_public}), protected member (for \tcode{is_protected}), or private member (for \tcode{is_private}), the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\end{std.txt}

% 21.11.4.7
\rSec3[reflect.ops.record]{Record operations}

\begin{std.txt}\color{addclr}
\pnum
A specialization of any of these templates with a meta-object type that is
reflecting an incomplete type renders the program ill-formed.  Such errors are
not in the immediate context (\cxxref{temp.deduct}).

\begin{itemdecl}
template <Record T> struct get_public_data_members;
template <Record T> struct get_accessible_data_members;
template <Record T> struct get_data_members;
template <Record T> struct get_public_member_functions;
template <Record T> struct get_accessible_member_functions;
template <Record T> struct get_member_functions;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized with \tcode{RecordMember} types that reflect the following subset of non-template members of the class reflected by \tcode{T}:
\begin{itemize}
  \item for \tcode{get_data_members} (\tcode{get_member_functions}), all data (function, including constructor and destructor) members.
  \item for \tcode{get_public_data_members} (\tcode{get_public_member_functions}), all public data (function, including constructor and destructor) members;
  \item for \tcode{get_accessible_data_members} (\tcode{get_accessible_member_functions}), all data (function, including constructor and destructor) members that are accessible from the context of the invocation of \tcode{reflexpr} which (directly or indirectly) generated \tcode{T}.
\begin{example}\begin{codeblock}
class X {
   int a;

   friend struct Y;
};

struct Y {
  using X_t = reflexpr(X);
};

using X_mem_t = get_accessible_data_members_t<Y::X_t>;
static_assert(get_size_v<X_mem_t> == 1); // passes.
\end{codeblock}\end{example}
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the declaration of the members in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.

\end{itemdescr}

\begin{itemdecl}
template <Record T> struct get_constructors;
template <Record T> struct get_operators;
\end{itemdecl}
\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized with \tcode{RecordMember} types that reflect the following subset of function members of the class reflected by \tcode{T}:
\begin{itemize}
   \item for \tcode{get_constructors}, all constructors.
   \item for \tcode{get_operators}, all conversion functions (\cxxref{class.conv.fct}) and operator functions (\cxxref{over.oper}).
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the declaration of the members in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Record T> struct get_destructor;
\end{itemdecl}
\begin{itemdescr}
\pnum
All specializations of \tcode{get_destructor<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to a \tcode{Destructor} type that reflects the destructor of the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Record T> struct get_public_member_types;
template <Record T> struct get_accessible_member_types;
template <Record T> struct get_member_types;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized with \tcode{Type} types that reflect the following subset of types declared in the class reflected by \tcode{T}:
\begin{itemize}
  \item for \tcode{get_public_member_types}, all public nested class types, enum types, or member typedefs;
  \item for \tcode{get_accessible_member_types}, all nested class types, enum types, or member typedefs that are accessible from the scope of the invocation of \tcode{reflexpr} which (directly or indirectly) generated \tcode{T};
  \item for \tcode{get_member_types}, all nested class types, enum types, or member typedefs.
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the first declaration of the types in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Class T> struct get_public_base_classes;
template <Class T> struct get_accessible_base_classes;
template <Class T> struct get_base_classes;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of these templates shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized with \tcode{Base} types that reflect the following subset of base classes of the class reflected by \tcode{T}:
\begin{itemize}
  \item for \tcode{get_public_base_classes}, all public direct base classes;
  \item for \tcode{get_accessible_base_classes}, all direct base classes whose public members are accessible from the scope of the invocation of \tcode{reflexpr} which (directly or indirectly) generated \tcode{T};
  \item for \tcode{get_base_classes}, all direct base classes.
\end{itemize}

\pnum
The order of the elements in the \tcode{ObjectSequence} is the order of the declaration of the base classes in the class reflected by \tcode{T}.

\pnum
\remarks
The program is ill-formed if \tcode{T} reflects a closure type.
\end{itemdescr}

\begin{itemdecl}
template <Class T> struct is_final<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_final<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a class that is marked with the \grammarterm{class-virt-specifier} \tcode{final}, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\end{std.txt}

% 21.11.4.8
\rSec3[reflect.ops.enum]{Enum operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Enum T> struct is_scoped_enum;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_scoped_enum<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a scoped enumeration, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.

\end{itemdescr}

\begin{itemdecl}
template <Enum T> struct get_enumerators;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_enumerators<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized with \tcode{Enumerator} types that reflect the enumerators of the enumeration type reflected by \tcode{T}.

\pnum
\remarks
A specialization of this template with a meta-object type that is reflecting an incomplete type renders the program ill-formed.
      Such errors are not in the immediate context (\cxxref{temp.deduct}).
\end{itemdescr}

\begin{itemdecl}
template <Enum T> struct get_underlying_type;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_underlying_type<T>} shall meet the
\tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named
\tcode{type} is an alias to a meta-object type that reflects the underlying type
(\cxxref{dcl.enum}) of the enumeration reflected by \tcode{T}.

\pnum
\remarks
A specialization of this template with a meta-object type that is reflecting an incomplete type renders the program ill-formed.
      Such errors are not in the immediate context (\cxxref{temp.deduct}).
\end{itemdescr}
\end{std.txt}

% 21.11.4.9
\rSec3[reflect.ops.value]{Value operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Constant T> struct get_constant;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_constant<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). The type and value of the static data member named \tcode{value} are those of the constant expression of the constant reflected by \tcode{T}.

\end{itemdescr}

\begin{itemdecl}
template <Variable T> struct is_constexpr<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_constexpr<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a variable declared with the \grammarterm{decl-specifier} \tcode{constexpr}, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Variable T> struct is_static<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_static<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a variable with static storage duration, the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Variable T> struct get_pointer<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_pointer<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}), with a static data member named \tcode{value} of type \tcode{X} and value \tcode{x}, where
\begin{itemize}
  \item for variables with static storage duration: \tcode{X} is \tcode{add_pointer<Y>}, where \tcode{Y} is the type of the variable reflected by \tcode{T} and \tcode{x} is the address of that variable; otherwise,
  \item \tcode{X} is the pointer-to-member type of the member variable reflected by \tcode{T} and \tcode{x} a pointer to that member.
\end{itemize}
\end{itemdescr}
\end{std.txt}

% 21.11.4.10
\rSec3[reflect.ops.derived]{Base operations}

\begin{std.txt}\color{addclr}
A specialization of any of these templates with a meta-object type that is reflecting an incomplete type renders the program ill-formed.
      Such errors are not in the immediate context (\cxxref{temp.deduct}).

\begin{itemdecl}
template <Base T> struct get_class;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{get_class<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to \tcode{reflexpr(\emph{X})}, where \tcode{\emph{X}} is the base class reflected by \tcode{T}.
\end{itemdescr}

\begin{itemdecl}
template <Base T> struct is_virtual<T>;
template <Base T> struct is_public<T>;
template <Base T> struct is_protected<T>;
template <Base T> struct is_private<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of the template and of these partial template specializations shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a direct base class with the \tcode{virtual} specifier (for \tcode{is_virtual}), with the \tcode{public} specifier or with an assumed (see \cxxref{class.access.base}) \tcode{public} specifier (for \tcode{is_public}), with the \tcode{protected} specifier (for \tcode{is_protected}), or with the \tcode{private} specifier or with an assumed \tcode{private} specifier (for \tcode{is_private}), then the base characteristic of the respective template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}

% 21.11.4.11
\rSec3[reflect.ops.namespace]{Namespace operations}

\begin{std.txt}\color{addclr}

\begin{itemdecl}
template <Namespace T> struct is_inline<T>;
\end{itemdecl}

\begin{itemdescr}
\pnum
All specializations of \tcode{is_inline<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects an inline namespace, the base characteristic of the template specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.

\end{itemdescr}
\end{std.txt}

% 21.11.4.12
\rSec3[reflect.ops.fctparam]{FunctionParameter operations }
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <FunctionParameter T> struct has_default_argument;
\end{itemdecl}
\begin{itemdescr}
\pnum
All specializations of this template shall meet the \tcode{UnaryTypeTrait}
requirements (\cxxref{meta.rqmts}). If \tcode{T} reflects a parameter with a default
argument, the base characteristic of \tcode{has_default_argument<T>} is
\tcode{true_type}, otherwise it is \tcode{false_type}.

\pnum
\remarks
Subsequent specializations of \tcode{has_default_argument<T>} on the same
reflected function parameter can render the program ill-formed, no diagnostic
required (\ref{reflect.ops}).
\end{itemdescr}
\end{std.txt}


% 21.11.4.13
\rSec3[reflect.ops.callable]{Callable operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Callable T> struct get_parameters;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of this template shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized with \tcode{FunctionParameter} types that reflect the parameters of the function reflected by \tcode{T}.
      If that function's \grammarterm{parameter-declaration-clause} (\cxxref{dcl.fct}) terminates with an ellipsis, the \tcode{ObjectSequence} does not contain any additional elements reflecting that. The \tcode{is_vararg_v<Callable>} trait can be used to determine if the terminating ellipsis is in its parameter list.
\end{itemdescr}

\begin{itemdecl}
template <Callable T> struct is_vararg;
template <Callable T> struct is_constexpr<T>;
template <Callable T> struct is_noexcept<T>;
template <Callable T> struct is_inline<T>;
template <Callable T> struct is_deleted;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}).  If their template
      parameter reflects an entity with an ellipsis terminating the
      \grammarterm{parameter-declaration-clause} (\cxxref{dcl.fct}) (for
      \tcode{is_vararg}), or an entity that is (where applicable implicitly or
      explicitly) declared as \tcode{constexpr} (for \tcode{is_constexpr}),
      as \tcode{noexcept} (for \tcode{is_noexcept}), as an inline function
      (\cxxref{dcl.inline}) (for \tcode{is_inline}), or as deleted (for
      \tcode{is_deleted}), the base characteristic of the respective template
      specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.

\pnum
\remarks
Subsequent specializations of \tcode{is_inline<T>} on the same reflected
function can render the program ill-formed, no diagnostic required
(\ref{reflect.ops}).
\end{itemdescr}
\end{std.txt}

% 21.11.4.14
\rSec3[reflect.ops.expr.paren]{ParenthesizedExpression operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <ParenthesizedExpression T> struct get_subexpression;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_subexpression<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Expression} type reflecting the expression \tcode{E} of the parenthesized expression \tcode{(E)} reflected by \tcode{T}. 
\end{itemdescr}
\end{std.txt}

% 21.11.4.16
\rSec3[reflect.ops.expr.fctcall]{FunctionCallExpression operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <FunctionCallExpression T> struct get_callable;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_callable<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type named \tcode{type} is the \tcode{Callable} type reflecting the function invoked by the \grammarterm{function-call-expression} which is reflected by \tcode{T}.
\end{itemdescr}
\end{std.txt}


% 21.11.4.16
\rSec3[reflect.ops.expr.fcttypeconv]{FunctionalTypeConversion operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <FunctionalTypeConversion T> struct get_constructor;
\end{itemdecl}
\begin{itemdescr}
\pnum
			All specializations of \tcode{get_constructor<T>} shall meet the \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). For a type conversion reflected by \tcode{T}, the nested type named \tcode{type} is the \tcode{Constructor} reflecting the constructor of the type specified by the type conversion, as selected by overload resolution.
      The program is ill-formed if no such constructor exists.
      \begin{note} For instance fundamental types (\cxxref{basic.fundamental}) do not have constructors. \end{note}
\end{itemdescr}
\end{std.txt}

% 21.11.4.17
\rSec3[reflect.ops.fct]{Function operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Function T> struct get_pointer<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_pointer<T>} shall meet the \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}), with a static data member named \tcode{value} of type \tcode{X} and value \tcode{x}, where
         \begin{itemize}
           \item for non-static member functions, \tcode{X} is the pointer-to-member-function type of the member function reflected by \tcode{T} and \tcode{x} a pointer to the member function; otherwise,
           \item \tcode{X} is \tcode{add_pointer<Y>}, where \tcode{Y} is the type of the function reflected by \tcode{T} and \tcode{x} is the address of that function. 
         \end{itemize}
\end{itemdescr}
\end{std.txt}

% 21.11.4.18
\rSec3[reflect.ops.memfct]{MemberFunction operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <MemberFunction T> struct is_static<T>;
template <MemberFunction T> struct is_const;
template <MemberFunction T> struct is_volatile;
template <MemberFunction T> struct has_lvalueref_qualifier;
template <MemberFunction T> struct has_rvalueref_qualifier;
template <MemberFunction T> struct is_virtual<T>;
template <MemberFunction T> struct is_pure_virtual<T>;
template <MemberFunction T> struct is_override;
template <MemberFunction T> struct is_final<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If their template
      parameter reflects a member function that is \tcode{static} (for
      \tcode{is_static}), \tcode{const} (for \tcode{is_const}),
      \tcode{volatile} (for \tcode{is_volatile}), declared with a
      \grammarterm{ref-qualifier} \tcode{\&} (for
      \tcode{has_lvalueref_qualifier}) or \tcode{\&\&} (for
      \tcode{has_rvalueref_qualifier}), implicitly or explicitly \tcode{virtual}
      (for \tcode{is_virtual}), pure virtual (for \tcode{is_pure_virtual}), or
      marked with \tcode{override} (for \tcode{is_override}) or \tcode{final}
      (for \tcode{is_final}), the base characteristic of the respective
      template specialization is \tcode{true_type}, otherwise it is
      \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


% 21.11.4.19
\rSec3[reflect.ops.specialfct]{SpecialMemberFunction operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <SpecialMemberFunction T> struct is_implicitly_declared;
template <SpecialMemberFunction T> struct is_defaulted;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If their template
      parameter reflects a special member function that is implicitly declared
      (for \tcode{is_implicitly_declared}) or that is defaulted in its first
      declaration (for \tcode{is_defaulted}), the base characteristic of the
      respective template specialization is \tcode{true_type}, otherwise it is
      \tcode{false_type}.
\end{itemdescr}
\end{std.txt}

% 21.11.4.20
\rSec3[reflect.ops.ctor]{Constructor operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Constructor T> struct is_explicit<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of this template shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an explicit constructor, the base characteristic of
      the respective template specialization is \tcode{true_type}, otherwise it
      is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


% 21.11.4.21
\rSec3[reflect.ops.dtor]{Destructor operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Destructor T> struct is_virtual<T>;
template <Destructor T> struct is_pure_virtual<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects a virtual (for \tcode{is_virtual}) or pure virtual
      (for \tcode{is_pure_virtual}) destructor, the base characteristic of the
      respective template specialization is \tcode{true_type}, otherwise it is
      \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


% 21.11.4.22
\rSec3[reflect.ops.convfct]{ConversionOperator operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <ConversionOperator T> struct is_explicit<T>;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_explicit<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an explicit conversion function, the base
      characteristic of the respective template specialization is
      \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


% 21.11.4.23
\rSec3[reflect.ops.lambda]{Lambda operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <Lambda T> struct get_captures;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{get_captures<T>} shall meet the
      \tcode{TransformationTrait} requirements (\cxxref{meta.rqmts}). The nested type
      named \tcode{type} is an alias to an \tcode{ObjectSequence} specialized
      with \tcode{LambdaCapture} types that reflect the captures of the closure
      object reflected by \tcode{T}.  The elements are in order of appearance
      in the \grammarterm{lambda-capture}; captures captured because of a
      \grammarterm{capture-default} have no defined order among the default
      captures.
\end{itemdescr}

\begin{itemdecl}
template <Lambda T> struct uses_default_copy_capture;
template <Lambda T> struct uses_default_reference_capture;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of these templates shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects a closure object with a \grammarterm{capture-default}
      that is \tcode{=} (for \tcode{uses_default_copy_capture}) or \tcode{\&}
      (for \tcode{uses_default_reference_capture}), the base characteristic of
      the respective template specialization is \tcode{true_type}, otherwise it
      is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <Lambda T> struct is_call_operator_const;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_call_operator_const<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects a closure object with a \tcode{const} function call
      operator, the base characteristic of the respective template
      specialization is \tcode{true_type}, otherwise it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}


% 21.11.4.24
\rSec3[reflect.ops.lambdacapture]{LambdaCapture operations}
\begin{std.txt}\color{addclr}
\begin{itemdecl}
template <LambdaCapture T> struct is_explicitly_captured;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_explicitly_captured<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an explicitly captured entity, the base characteristic
      of the respective template specialization is \tcode{true_type}, otherwise
      it is \tcode{false_type}.
\end{itemdescr}

\begin{itemdecl}
template <LambdaCapture T> struct is_init_capture;
\end{itemdecl}
\begin{itemdescr}
\pnum
      All specializations of \tcode{is_init_capture<T>} shall meet the
      \tcode{UnaryTypeTrait} requirements (\cxxref{meta.rqmts}). If the template
      parameter reflects an \grammarterm{init-capture}, the base characteristic
      of the respective template specialization is \tcode{true_type}, otherwise
      it is \tcode{false_type}.
\end{itemdescr}
\end{std.txt}
